import threading
import socket
import time
import PyKDL as kdl
import numpy as np
import collections
import matplotlib.pyplot as plt

from ABBRobotEGM import EGM

# ------------------ PARÁMETROS ------------------ #
TIME_INTERVAL = 0.001
STEPS = 100
GAIN = 10  # Ganancia (mm/N)
MAX_CORRECTION_MM = 50.0  # Límite de corrección permitido por el robot
OFFSET = None
DELAY = 10

# ------------------ VARIABLES GLOBALES ------------------ #
t = np.arange(0, STEPS)
torques = collections.deque(np.zeros(t.shape))
limits = [0.0, 0.0]
force_z = 0.0
lock = threading.Lock()
fz_values = collections.deque(np.zeros(STEPS), maxlen=STEPS)
joint_position = kdl.JntArray(6)
joint_velocity = kdl.JntArray(6)
joint_torque = kdl.JntArray(6)
wrench = kdl.Wrench()

# Modelo KDL
chain = kdl.Chain()
frames = [
    kdl.Frame.DH(0, np.deg2rad(-90), 0.265, 0),
    kdl.Frame.DH(0.444, 0, 0, np.deg2rad(-90)),
    kdl.Frame.DH(0.110, np.deg2rad(-90), 0, 0),
    kdl.Frame.DH(0, np.deg2rad(90), 0.470, 0),
    kdl.Frame.DH(0.080, np.deg2rad(-90), 0, 0),
    kdl.Frame.DH(0, 0, 0.101, np.deg2rad(180))
]
joint = kdl.Joint(kdl.Joint.RotZ)

for H in frames:
    chain.addSegment(kdl.Segment(joint, H))

chain.addSegment(kdl.Segment(kdl.Joint(kdl.Joint.Fixed), kdl.Frame(kdl.Vector(0, 0, 0.080))))

gravity = kdl.Vector(0, 0, -9.8)
estimator = kdl.ChainExternalWrenchEstimator(chain, gravity, 20, 1, 0)

# ------------------ CONFIGURACIÓN DE LA GRÁFICA ------------------ #
plt.ion()
fig, ax = plt.subplots()
line, = ax.plot(list(fz_values), label='F_z [N]', color='blue')
ax.set_ylim(-50, 100)
ax.set_title('Fuerza estimada en Z')
ax.set_xlabel('Tiempo (muestras)')
ax.set_ylabel('F_z [N]')
ax.legend()
ax.grid(True)

# ------------------ HILO DE LECTURA DE SENSORES ------------------ #
def sensor_reader():
    global force_z, OFFSET
    mi_socket = socket.socket()
    print("[WSL] Esperando datos del robot...")
    mi_socket.connect(("192.168.125.1", 1025))
    print("[Socket] Mensaje inicial:", mi_socket.recv(1024).decode())

    start = time.time()
    prev_index = 0

    while True:
        try:
            data = mi_socket.recv(1024).decode('utf-8').strip()

            if len(data) < 3:
                continue

            index = int(data[0])
            # print(data)

            arr = data[2:].split('|')

            if len(arr) != 3:
                # print(f"[ERROR WSL] Formato incorrecto: {data}")
                continue  # Ignora esta lectura pero sigue

            if index != 1 and index != prev_index + 1:
                prev_index = 0
                continue

            prev_index = index

            joint_position[index - 1] = float(arr[0])
            joint_velocity[index - 1] = float(arr[1])
            joint_torque[index - 1] = float(arr[2])

            # for i in range(6):
            #     campo_limpio = arr[i].replace('[', '').replace(']', '').strip()
            #     partes = campo_limpio.split('|')

            #     if len(partes) != 3:
            #         print(f"[ERROR WSL] Formato incorrecto en campo {i}: {arr[i]}")
            #         continue  # Ignora esta lectura pero sigue

            #     try:
            #         pos, vel, trq = map(float, partes)
            #         joint_position[i] = pos
            #         joint_velocity[i] = vel
            #         joint_torque[i] = trq
            #     except ValueError:
            #         print(f"[ERROR WSL] Conversión fallida en campo {i}: {partes}")
            #         continue

            if index == 6:
                estimator.JntToExtWrench(joint_position, joint_velocity, joint_torque, wrench)

                # CORRECIÓN TRAYECTORIA
                fz = wrench.force.z()

                # print(f"[WSL] Fz = {fz:.2f} N → Z_corr = {GAIN * fz:.2f}")

                if (time.time() - start) < DELAY:
                    continue

                if OFFSET is None:
                    OFFSET = fz
                    fz = 0.0
                else:
                    fz = OFFSET - fz

                # print(fz)

                with lock:
                    force_z = fz
        except Exception as e:
            print("[Error] Lectura de sensores:", e)
            break

    mi_socket.close()

# ------------------ CORRECCIÓN DE TRAYECTORIA POR EGM ------------------ #
def main():
    # Iniciar hilos
    threading.Thread(target=sensor_reader, daemon=True).start()

    while True:
        with lock:
            offs = OFFSET

        if offs is None:
            time.sleep(0.1)
            continue

        break

    print(force_z)

    # Conexión EGM con el robot
    with EGM() as egm:
        print("[EGM] Esperando conexión con el robot...")
        while True:
            success, _ = egm.receive_from_robot(timeout=1.0)
            if success:
                print("[EGM] ¡Conectado al robot!")
                break

        print("[EGM] Aplicando correcciones en Z en función de Fz...")

        while True:
            success, _ = egm.receive_from_robot(timeout=0.1)
            if not success:
                print("[EGM] Conexión EGM perdida.")
                break

            with lock:
                fz = force_z * GAIN

            # Limitar fuerza para evitar sobresalto
            fz_limited = max(min(fz, MAX_CORRECTION_MM), -MAX_CORRECTION_MM)
            # z_correction = GAIN * fz_limited
            z_correction = 0.0 # FIXME

            print(f"[EGM] Fz = {fz:.2f} N → Z_correction = {z_correction:.2f} mm")

            correction = np.array([0.0, 0.0, z_correction])  # Solo eje Z
            egm.send_to_robot_path_corr(correction, age=1)

            # Actualizar gráfica
            fz_values.append(fz)
            line.set_ydata(fz_values)
            line.set_xdata(range(len(fz_values)))
            ax.relim()
            ax.autoscale_view()
            fig.canvas.draw()
            fig.canvas.flush_events()

            torques.popleft()
            torques.append(fz)

            limits[0] = min(limits[0], fz)
            limits[1] = max(limits[1], fz)

            time.sleep(0.048)  # ~20 Hz

# ------------------ EJECUCIÓN ------------------ #
if __name__ == "__main__":
    main()
