# Applies real-time Z-axis trajectory corrections to an ABB robot using estimated external force (Fz) via EGM and PyKDL

import threading
import socket
import time
import PyKDL as kdl
import numpy as np
import collections
import matplotlib.pyplot as plt

from ABBRobotEGM import EGM

# ------------------ PARAMETERS -------------------------- #
TIME_INTERVAL = 0.001              # Time step for plot updates (s)
STEPS = 100                        # Number of samples to display
GAIN = 10                          # Z correction gain [mm/N]
MAX_CORRECTION_MM = 50.0           # Max correction allowed in Z [mm]
OFFSET = None                      # Initial Fz value for offset correction
DELAY = 10                         # Time to ignore data (robot stabilizing)

# ------------------ GLOBAL VARIABLES -------------------- #
t = np.arange(0, STEPS)
torques = collections.deque(np.zeros(t.shape)) # Stores Fz history
limits = [0.0, 0.0]
force_z = 0.0
lock = threading.Lock()
fz_values = collections.deque(np.zeros(STEPS), maxlen=STEPS) # For plotting
joint_position = kdl.JntArray(6)
joint_velocity = kdl.JntArray(6)
joint_torque = kdl.JntArray(6)
wrench = kdl.Wrench()

# ------------------ KDL ROBOT MODEL --------------------- #
chain = kdl.Chain()
frames = [
    kdl.Frame.DH(0, np.deg2rad(-90), 0.265, 0),
    kdl.Frame.DH(0.444, 0, 0, np.deg2rad(-90)),
    kdl.Frame.DH(0.110, np.deg2rad(-90), 0, 0),
    kdl.Frame.DH(0, np.deg2rad(90), 0.470, 0),
    kdl.Frame.DH(0.080, np.deg2rad(-90), 0, 0),
    kdl.Frame.DH(0, 0, 0.101, np.deg2rad(180))
]
joint = kdl.Joint(kdl.Joint.RotZ)

for H in frames:
    chain.addSegment(kdl.Segment(joint, H))

chain.addSegment(kdl.Segment(kdl.Joint(kdl.Joint.Fixed), kdl.Frame(kdl.Vector(0, 0, 0.080))))

# External wrench estimator (gravity = -Z)
gravity = kdl.Vector(0, 0, -9.8)
estimator = kdl.ChainExternalWrenchEstimator(chain, gravity, 20, 1, 0)

# ------------------ PLOT SETUP ------------------------- #
plt.ion()
fig, ax = plt.subplots()
line, = ax.plot(list(fz_values), label='F_z [N]', color='blue')
ax.set_ylim(-50, 100)
ax.set_title('Estimated Force in Z')
ax.set_xlabel('Time (samples)')
ax.set_ylabel('F_z [N]')
ax.legend()
ax.grid(True)

# ----------------- SENSOR READING THREAD --------------- #
def sensor_reader():
    global force_z, OFFSET
    mi_socket = socket.socket()
    print("[WSL] Waiting for robot data...")
    mi_socket.connect(("192.168.125.1", 1025))
    print("[Socket] Initial message:", mi_socket.recv(1024).decode())

    start = time.time()
    prev_index = 0

    while True:
        try:
            data = mi_socket.recv(1024).decode('utf-8').strip()

            if len(data) < 3:
                continue

            index = int(data[0])
            arr = data[2:].split('|')

            if len(arr) != 3:
                continue  # Skip invalid lines

            # Ensure ordered reception of 1–6
            if index != 1 and index != prev_index + 1:
                prev_index = 0
                continue
            prev_index = index

            joint_position[index - 1] = float(arr[0])
            joint_velocity[index - 1] = float(arr[1])
            joint_torque[index - 1] = float(arr[2])

            # Once full joint state received
            if index == 6:
                estimator.JntToExtWrench(joint_position, joint_velocity, joint_torque, wrench)
                fz = wrench.force.z()

                # Ignore initial readings for stability
                if (time.time() - start) < DELAY:
                    continue

                if OFFSET is None:
                    OFFSET = fz
                    fz = 0.0
                else:
                    fz = OFFSET - fz

                with lock:
                    force_z = fz
        except Exception as e:
            print("[Error] Sensor reading failed:", e)
            break

    mi_socket.close()

# ---------------- MAIN EGM CONTROL LOOP ----------------- #
def main():
    # Start sensor reading thread
    threading.Thread(target=sensor_reader, daemon=True).start()

    while True:
        with lock:
            offs = OFFSET

        if offs is None:
            time.sleep(0.1)
            continue
        break

    print(force_z)

    # Start EGM communication
    with EGM() as egm:
        print("[EGM] Waiting for connection...")
        while True:
            success, _ = egm.receive_from_robot(timeout=1.0)
            if success:
                print("[EGM] Connected to robot.")
                break

        print("[EGM] Sending Z corrections based on Fz...")

        while True:
            success, _ = egm.receive_from_robot(timeout=0.1)
            if not success:
                print("[EGM] EGM connection lost.")
                break

            with lock:
                fz = force_z * GAIN

            # Clamp correction to safety limits
            fz_limited = max(min(fz, MAX_CORRECTION_MM), -MAX_CORRECTION_MM)
            z_correction = 0.0 

            print(f"[EGM] Fz = {fz:.2f} N → Z_correction = {z_correction:.2f} mm")

            correction = np.array([0.0, 0.0, z_correction])  # Apply correction in Z only
            egm.send_to_robot_path_corr(correction, age=1)

            # Update plot
            fz_values.append(fz)
            line.set_ydata(fz_values)
            line.set_xdata(range(len(fz_values)))
            ax.relim()
            ax.autoscale_view()
            fig.canvas.draw()
            fig.canvas.flush_events()

            torques.popleft()
            torques.append(fz)

            limits[0] = min(limits[0], fz)
            limits[1] = max(limits[1], fz)

            time.sleep(0.048)  # ~20 Hz control loop

# ------------------ EXECUTION ------------------- #
if __name__ == "__main__":
    main()
